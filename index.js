#!/usr/bin/env node
import{readFileSync as e}from"fs";import t from"node:readline/promises";var r,n={input:{fn:async function(r){let n=t.createInterface({input:process.stdin,output:process.stdout}),s=await n.question(r);return n.close(),s},paramsType:["str"],requiredArgs:1,returnType:"str"},string:{fn:async function(r){return Promise.resolve(String(r))},paramsType:["num"],requiredArgs:1,returnType:"str"},number:{fn:async function(r){return await Promise.resolve(Number(r))},paramsType:["str"],requiredArgs:1,returnType:"num"}};class s{}class i{}class a{constructor(r){this.statements=r}}class o{constructor(r){this.type=r}}class l extends s{}class c extends l{constructor(r){super(),this.value=r,this.type="str"}}class u extends l{constructor(r){super(),this.value=r,this.type="num"}}class h extends l{constructor(){super(),this.type="none",this.value="None"}}class p extends l{constructor(r){super(),this.value=r,this.type="bool"}}class E extends s{constructor(r){super(),this.value=r}}class f extends i{constructor(r,n,s,i){super(),this.variableName=r,this.variableType=n,this.variableValue=s,this.line=i}}class T extends i{constructor(r,n,s){super(),this.variableName=r,this.variableValue=n,this.line=s}}class d extends s{}class y extends d{constructor(r,n){super(),this.leftOperand=r,this.rightOperand=n}}class v extends d{constructor(r,n){super(),this.leftOperand=r,this.rightOperand=n}}class x extends d{constructor(r,n){super(),this.leftOperand=r,this.rightOperand=n}}class S extends d{constructor(r,n){super(),this.leftOperand=r,this.rightOperand=n}}class w extends s{constructor(r){super(),this.operand=r}}class N extends s{}class O extends N{constructor(r,n){super(),this.leftOperand=r,this.rightOperand=n}}class A extends N{constructor(r,n){super(),this.leftOperand=r,this.rightOperand=n}}class b extends N{constructor(r,n){super(),this.leftOperand=r,this.rightOperand=n}}class m extends N{constructor(r,n){super(),this.leftOperand=r,this.rightOperand=n}}class L extends N{constructor(r,n){super(),this.leftOperand=r,this.rightOperand=n}}class R extends N{constructor(r,n){super(),this.leftOperand=r,this.rightOperand=n}}class g extends s{}class k extends g{constructor(r,n){super(),this.leftOperand=r,this.rightOperand=n}}class I extends g{constructor(r,n){super(),this.leftOperand=r,this.rightOperand=n}}class _ extends i{constructor(r,n,s){super(),this.conditional=r,this.ifBlock=n,this.line=s}}class C extends i{constructor(r,n){super(),this.elseBlock=r,this.line=n}}class P extends i{constructor(r,n,s,i,a){super(),this.conditional=r,this.ifBlock=n,this.line=s,this.elseIfBlock=i,this.elseBlock=a}}class $ extends i{constructor(r,n,s){super(),this.conditional=r,this.block=n,this.line=s}}class U extends i{constructor(r,n){super(),this.args=r,this.line=n}}class F extends i{constructor(r,n){super(),this.returnValue=r,this.line=n}}class V extends s{constructor(r,n){super(),this.paramName=r,this.paramType=n}}class B extends i{constructor(r,n,s,i,a){super(),this.functionName=r,this.params=n,this.returnType=s,this.body=i,this.line=a}}class M extends s{constructor(r,n,s){super(),this.functionName=r,this.args=n,this.line=s}}class D{constructor(){this.functions=new Map,this.currentScope="global",this.functions.set(this.currentScope,new Map)}enterScope(r){this.currentScope=`${this.currentScope}=>${r}`,this.functions.has(this.currentScope)||this.functions.set(this.currentScope,new Map)}exitScope(){this.functions.delete(this.currentScope);let r=Array.from(this.functions.keys());this.currentScope=r[r.length-1]||"global"}addFunction(r){let{functionName:n,params:s}=r,i=n.value,a=this.functions.get(this.currentScope);if(!a.has(n.value))return a.set(i,[r]);let o=a.get(n.value);for(let e of o){if(!e.params.length&&!s.length)throw SyntaxError(`SyntaxError: Function '${n.value}' is already defined.`);if(e.params.length===s.length&&e.params.every((e,t)=>e.paramType===s[t].paramType))throw SyntaxError(`SyntaxError: Function '${n.value}' is already defined with the same parameter types.`)}return o.push(r),a.set(n.value,o)}getFunction(r,n){let s=Array.from(this.functions.keys()).reverse();for(let e of s){let t=this.functions.get(e);if(t.has(r)){let e=t.get(r);for(let t of e)if(t.params.every((e,t)=>e.paramType.type===n[t].type))return t;throw TypeError(`TypeError: No matching function found for call to '${r}'`)}}throw ReferenceError(`ReferenceError: Function '${r}' is not defined.`)}}class H{constructor(){this.variables=new Map,this.currentScope="global",this.variables.set(this.currentScope,new Map)}enterScope(r){this.currentScope=`${this.currentScope}=>${r}`,this.variables.has(this.currentScope)||this.variables.set(this.currentScope,new Map)}exitScope(){this.variables.delete(this.currentScope);let r=Array.from(this.variables.keys());this.currentScope=r[r.length-1]||"global"}addVariable(r,n){let s=this.variables.get(this.currentScope);if(s&&!s.has(r))return s.set(r,n);throw SyntaxError(`SyntaxError: Variable '${r}' has already been declared.`)}getVariableValue(r){let n=Array.from(this.variables.keys()).reverse();for(let e of n){let t=this.variables.get(e);if(t&&t.has(r))return t.get(r)}throw ReferenceError(`ReferenceError: Variable '${r}' is not defined.`)}updateVariableValue(r,n,s){let i=Array.from(this.variables.keys()).reverse();for(let e of i){let t=this.variables.get(e);if(t&&t.has(r)){let e=this.getVariableValue(r)?.type;if(n.type===e)return t.set(r,n);throw TypeError(`TypeError: Type '${n.type}' is not assignable to variable type '${e}' at line ${s}.`)}}throw ReferenceError(`ReferenceError: Variable '${r}' is not declared.`)}}!function(r){r.STRING="str",r.NUMBER="num",r.BOOLEAN="bool",r.IDENTIFIER="identifier",r.ASSIGNMENT="=",r.OPEN_PAREN="(",r.CLOSE_PAREN=")",r.OPEN_BRACE="{",r.CLOSE_BRACE="}",r.IF="if",r.ELSE="else",r.RETURN="return",r.WHILE="while",r.COMMA=",",r.SEMICOLON=";",r.COLON=":",r.TYPE_ANNOTATION="type_annotation",r.DOUBLE_COLON="::",r.ARROW="=>",r.NEW_LINE="new_line",r.FUNCTION="function",r.PRINT="print",r.PLUS="+",r.MINUS="-",r.DIVIDE="/",r.MULTIPLY="*",r.EQUAL="==",r.NOT_EQUAL="!=",r.GREATER_THAN=">",r.LESS_THAN="<",r.GREATER_THAN_OR_EQUAL=">=",r.LESS_THAN_OR_EQUAL="<=",r.AND="&&",r.OR="||"}(r||(r={}));class Q{constructor(r,n,s){this.type=r,this.value=n,this.line=s}}let G=new Map([["if",r.IF],["else",r.ELSE],["fn",r.FUNCTION],["rn",r.RETURN],["=",r.ASSIGNMENT],[";",r.SEMICOLON],[":",r.COLON],["{",r.OPEN_BRACE],["}",r.CLOSE_BRACE],["(",r.OPEN_PAREN],[")",r.CLOSE_PAREN],[",",r.COMMA],["+",r.PLUS],["-",r.MINUS],["*",r.MULTIPLY],["/",r.DIVIDE],["print",r.PRINT],["=>",r.ARROW],["&&",r.AND],["||",r.OR],["==",r.EQUAL],["!=",r.NOT_EQUAL],[">=",r.GREATER_THAN_OR_EQUAL],["<=",r.LESS_THAN_OR_EQUAL],[">",r.GREATER_THAN],["<",r.LESS_THAN],["::",r.DOUBLE_COLON],["str",r.TYPE_ANNOTATION],["num",r.TYPE_ANNOTATION],["none",r.TYPE_ANNOTATION],["bool",r.TYPE_ANNOTATION],["true",r.BOOLEAN],["false",r.BOOLEAN],["while",r.WHILE]]),W=/(["'`])((?:\\.|\\\1|(?!\1)[\s\S])*?)\1/,Y=/(?:\d+(?:\.\d*)?|\.\d+)(?:[eE][-+]?\d+)?/,q=/[a-zA-Z_]\w*/,z=[[W],[Y],[q],[/=|\(|\)|\{|\}|,|;|::|:|\+|\*|-|\/|\n/],[/&&|\|\||>=|<=|==|!=|>|<|=>/]].map(([r])=>r.source).join("|");try{let i=process.argv.slice(2),Z=e(i[0]).toString(),j=new class{constructor(e){this.sourceCode=e,this.src=this.sourceCode.trim().match(RegExp(z,"g")),this.currentToken=this.src.shift()||null,this.currentLine=1}getTokenTypeAndValue(e){let t=G.get(e);if(t)return[t,e];if(W.test(e))return[r.STRING,e];if(Y.test(e))return[r.NUMBER,e];if(q.test(e))return[r.IDENTIFIER,e];let n=this.currentLine;throw SyntaxError(`SyntaxError: Unexpected token '${e}' at line ${n}.`)}getTokens(){let e=[];for(;this.currentToken;){let t=this.currentToken;if("\n"===t){this.currentLine++,this.currentToken=this.src.shift()||null;continue}let[r,n]=this.getTokenTypeAndValue(t);this.currentToken=this.src.shift()||null,e.push(new Q(r,n,this.currentLine))}return e}lex(){return this.getTokens()}}(Z),J=j.lex(),K=new class{constructor(e){this.tokens=e,this.currentToken=null,this.currentLine=0,this.advance()}advance(){this.currentToken=this.tokens.shift()||null,this.currentLine=this.currentToken?.line||this.currentLine}expect(e){if(this.currentToken?.type!==e){let t=this.currentLine;if(!this.currentToken?.value)throw SyntaxError(`SyntaxError: Expected '${e}' at line ${t}.`);if(this.currentToken.type===r.IDENTIFIER)throw SyntaxError(`SyntaxError: Expected '${e}' but found ${this.currentToken.type} '${this.currentToken?.value}' at line ${t}.`);throw SyntaxError(`SyntaxError: Expected '${e}' but found '${this.currentToken.value}' at line ${t}.`)}this.advance()}parseExpression(){let e=this.parseConditionalExpression();for(;this.currentToken?.type===r.AND||this.currentToken?.type===r.OR;){let t=this.currentToken.type;this.advance();let n=this.parseConditionalExpression();t===r.AND?e=new k(e,n):t===r.OR&&(e=new I(e,n))}return e}parseConditionalExpression(){let e=this.parseArithmeticExpression();for(;this.currentToken?.type===r.EQUAL||this.currentToken?.type===r.NOT_EQUAL||this.currentToken?.type===r.GREATER_THAN||this.currentToken?.type===r.LESS_THAN||this.currentToken?.type===r.GREATER_THAN_OR_EQUAL||this.currentToken?.type===r.LESS_THAN_OR_EQUAL;){let t=this.currentToken.type;this.advance();let n=this.parseArithmeticExpression();t===r.EQUAL?e=new O(e,n):t===r.NOT_EQUAL?e=new A(e,n):t===r.GREATER_THAN?e=new b(e,n):t===r.LESS_THAN?e=new m(e,n):t===r.GREATER_THAN_OR_EQUAL?e=new L(e,n):t===r.LESS_THAN_OR_EQUAL&&(e=new R(e,n))}return e}parseArithmeticExpression(){let e=this.parseTerm();for(;this.currentToken?.type===r.PLUS||this.currentToken?.type===r.MINUS;){let t=this.currentToken.type;this.advance();let n=this.parseTerm();t===r.MINUS?e=new v(e,n):t===r.PLUS&&(e=new y(e,n))}return e}parseTerm(){let e=this.parseFactor();for(;this.currentToken?.type===r.MULTIPLY||this.currentToken?.type===r.DIVIDE;){let t=this.currentToken.type;this.advance();let n=this.parseFactor();t===r.MULTIPLY?e=new S(e,n):t===r.DIVIDE&&(e=new x(e,n))}return e}parseFactor(){if(this.currentToken?.type===r.IDENTIFIER){let e=this.currentToken.value;return(this.advance(),this.currentToken.type===r.OPEN_PAREN)?this.parseFunctionCall(e):new E(e)}if(this.currentToken?.type===r.STRING){let e=this.currentToken.value;return this.advance(),new c(e.slice(1,-1))}if(this.currentToken?.type===r.NUMBER){let e=this.currentToken.value;return this.advance(),new u(Number(e))}if(this.currentToken?.type===r.BOOLEAN){let e=this.currentToken.value;return this.advance(),new p("true"===e)}if(this.currentToken?.type===r.MINUS){this.advance();let e=this.parseFactor();return new w(e)}if(this.currentToken?.type===r.OPEN_PAREN){this.advance();let e=this.parseExpression();return this.expect(r.CLOSE_PAREN),e}{let e=this.currentToken?.line||0;throw SyntaxError(`SyntaxError: Unexpected token '${this.currentToken?.value}' at line ${e}.`)}}parseVariableDeclaration(e){let t=this.currentLine;this.advance();let n=this.currentToken?.value;this.expect(r.TYPE_ANNOTATION),this.expect(r.ASSIGNMENT);let s=this.parseExpression();return this.expect(r.SEMICOLON),new f(new E(e),new o(n),s,t)}parseAssignmentVariable(e){let t=this.currentLine;this.advance();let n=this.parseExpression();return this.expect(r.SEMICOLON),new T(new E(e),n,t)}parsePrint(){let e=this.currentLine;this.advance();let t=[];for(t.push(this.parseExpression());this.currentToken?.type===r.COMMA;)this.advance(),t.push(this.parseExpression());return this.expect(r.SEMICOLON),new U(t,e)}parseFunctionParameter(){let e=this.currentToken?.value;this.expect(r.IDENTIFIER),this.expect(r.COLON);let t=this.currentToken?.value;return this.expect(r.TYPE_ANNOTATION),new V(new E(e),new o(t))}parseReturn(){let e=this.currentLine,t=this.parseExpression();return this.expect(r.SEMICOLON),new F(t,e)}parseFunctionDefinition(){let e=this.currentLine;this.advance();let t=this.currentToken?.value;this.expect(r.IDENTIFIER);let n="none",s=[];for(;this.currentToken?.type!==r.OPEN_BRACE&&this.currentToken?.type!==r.DOUBLE_COLON&&this.currentToken?.type!==r.ARROW;){let e=this.parseFunctionParameter();s.push(e)}if(this.currentToken?.type===r.DOUBLE_COLON&&(this.advance(),n=this.currentToken?.value,this.expect(r.TYPE_ANNOTATION)),this.currentToken?.type===r.ARROW){this.advance();let r=[];return r.push(this.parseReturn()),new B(new E(t),s,new o(n),new a(r),e)}this.expect(r.OPEN_BRACE);let i=this.parseProgram();return this.expect(r.CLOSE_BRACE),new B(new E(t),s,new o(n),i,e)}parseFunctionCall(e){let t=this.currentLine;this.advance();let n=[];for(this.currentToken?.type!==r.CLOSE_PAREN&&n.push(this.parseExpression());this.currentToken?.type===r.COMMA;)this.advance(),n.push(this.parseExpression());return this.expect(r.CLOSE_PAREN),new M(new E(e),n,t)}parseIfStatement(){let e;let t=this.currentLine;this.advance();let n=this.parseExpression();this.expect(r.OPEN_BRACE);let s=this.parseProgram();this.expect(r.CLOSE_BRACE);let i=[];for(;this.currentToken?.type===r.ELSE;){let t=this.currentLine;if(this.advance(),this.currentToken?.type===r.IF){let e=this.currentLine;this.advance();let t=this.parseExpression();this.expect(r.OPEN_BRACE);let n=this.parseProgram();this.expect(r.CLOSE_BRACE),i.push(new _(t,n,e))}else{this.expect(r.OPEN_BRACE);let n=this.parseProgram();this.expect(r.CLOSE_BRACE),e=new C(n,t)}}return new P(n,s,t,i,e)}parseWhileStatement(){let e=this.currentLine;this.advance();let t=this.parseConditionalExpression();this.expect(r.OPEN_BRACE);let n=this.parseProgram();return this.expect(r.CLOSE_BRACE),new $(t,n,e)}parseStatement(){switch(this.currentToken?.type){case r.WHILE:return this.parseWhileStatement();case r.IF:return this.parseIfStatement();case r.FUNCTION:return this.parseFunctionDefinition();case r.RETURN:return this.advance(),this.parseReturn();case r.PRINT:return this.parsePrint();case r.IDENTIFIER:{let e=this.currentToken.value;switch(this.advance(),this.currentToken?.type){case r.COLON:return this.parseVariableDeclaration(e);case r.ASSIGNMENT:return this.parseAssignmentVariable(e);case r.OPEN_PAREN:return this.parseFunctionCall(e)}}}let e=this.currentToken?.line||0;throw SyntaxError(`SyntaxError: Unexpected token '${this.currentToken?.value}' at line ${e}.`)}parseProgram(){let e=[];for(;this.currentToken&&this.currentToken.type!==r.CLOSE_BRACE;){let t=this.parseStatement();e.push(t)}return new a(e)}parse(){return this.parseProgram()}}(J),X=K.parse(),ee=new class{constructor(){this.variableTable=new H,this.functionTable=new D}async interpret({statements:e}){for(let t of e){let e=await this.executeStatement(t);if(e)return e}}async executeStatement(e){if(e instanceof f)await this.executeVariableDeclaration(e);else if(e instanceof T)await this.executeAssigmentVariable(e);else if(e instanceof U)await this.executePrint(e);else if(e instanceof B)this.executeFunctionDefinition(e);else if(e instanceof M)await this.executeFunctionCall(e);else if(e instanceof F)return await this.executeReturn(e);else if(e instanceof P){let t=await this.executeIfElseStatement(e);if(!(t instanceof h))return t}else if(e instanceof $){let t=await this.executeWhileStatementNode(e);if(!(t instanceof h))return t}else throw SyntaxError("SyntaxError: Invalid statement.")}async executeWhileStatementNode(e){let t=await this.evaluateExpression(e.conditional),r=new h;if(t.value){if(this.functionTable.enterScope("while"),this.variableTable.enterScope("while"),r=await this.interpret(e.block)||new h,this.variableTable.exitScope(),this.functionTable.exitScope(),!(r instanceof h))return r;await this.executeWhileStatementNode(e)}return r}async executeIfElseStatement({conditional:e,ifBlock:t,elseIfBlock:r,elseBlock:n}){let s=await this.evaluateExpression(e);if(s.value){this.functionTable.enterScope("if"),this.variableTable.enterScope("if");let e=await this.interpret(t)||new h;return this.variableTable.exitScope(),this.functionTable.exitScope(),e}for(let{conditional:e,ifBlock:t}of r){let r=await this.evaluateExpression(e);if(r.value){this.functionTable.enterScope("if"),this.variableTable.enterScope("if");let e=await this.interpret(t)||new h;return this.variableTable.exitScope(),this.functionTable.exitScope(),e}}if(n){this.functionTable.enterScope("else"),this.variableTable.enterScope("else");let e=await this.interpret(n.elseBlock)||new h;return this.variableTable.exitScope(),this.functionTable.exitScope(),e}}async executeVariableDeclaration(e){let t=e.variableName.value,r=e.variableType.type,n=await this.evaluateExpression(e.variableValue);if(n.type!==r)throw TypeError(`TypeError: Type '${n.type}' is not assignable to variable type '${r}' at line ${e.line}.`);this.variableTable.addVariable(t,n)}async executeAssigmentVariable(e){let t=e.variableName.value,r=await this.evaluateExpression(e.variableValue);this.variableTable.updateVariableValue(t,r,e.line)}async executePrint(e){let t=e.args,r=[];for await(let e of t){let t=(await this.evaluateExpression(e)).value;r.push(t)}console.log(...r)}executeFunctionDefinition(e){this.functionTable.addFunction(e)}async executeReturn(e){return await this.evaluateExpression(e.returnValue)}async executeFunctionCall(e){let t=e.functionName.value,r=[];for await(let t of e.args){let e=await this.evaluateExpression(t);r.push(e)}let s=n[t];if(s){if(r.length<s.requiredArgs||r.length>s.paramsType.length)throw Error(`Error: required ${s.requiredArgs} argument type '${s.paramsType.join(",")}' but found ${r.length} argument at line ${e.line}`);for(let t=0;t<r.length;t++)if(r[t].type!==s.paramsType[t])throw Error(`TypeError: Argument type '${r[t].type}' is not assignable to parameter type '${s.paramsType[t]}' at line ${e.line}.`);let t=await s.fn(...r.map(e=>e.value));if("str"===s.returnType)return new c(t);if("num"===s.returnType)return new u(t)}let{params:i,body:a,returnType:o,line:l}=this.functionTable.getFunction(t,r);this.variableTable.enterScope(t),this.functionTable.enterScope(t);for(let e=0;e<i.length;e++){let t=i[e].paramName.value,n=r[e];this.variableTable.addVariable(t,n)}let p=await this.interpret(a)||new h;if(this.functionTable.exitScope(),this.variableTable.exitScope(),p.type!==o.type)throw TypeError(`TypeError: Type '${p.type}' is not assignable to 'return' type '${o.type}' at line ${l}.`);return p}async evaluateArithmeticExpression(e){let t=await this.evaluateExpression(e.leftOperand),r=await this.evaluateExpression(e.rightOperand);if("str"===t.type&&"str"===r.type&&e instanceof y)return new c(t.value+r.value);if("num"!==t.type||"num"!==r.type)throw TypeError(`TypeError: unsupported operand type(s) for: '${t.type}' and '${r.type}'`);switch(e.constructor){case y:return new u(t.value+r.value);case v:return new u(t.value-r.value);case S:return new u(t.value*r.value);case x:return new u(t.value/r.value);default:throw SyntaxError("SyntaxError: Invalid arithmetic expression.")}}evaluateString(e){let t=e.match(/{[a-zA-Z_]+}|{[a-zA-Z_][a-zA-Z0-9_]+}/g);if(t){let r=t.map(e=>this.variableTable.getVariableValue(e.slice(1,-1)));r.forEach((r,n)=>{e=e.replace(`${t[n]}`,`${r?.value}`)})}return new c(e)}async evaluateLogicalExpression(e){let t=await this.evaluateExpression(e.leftOperand),r=await this.evaluateExpression(e.rightOperand);switch(e.constructor){case k:return!!t.value&&!!r.value;case I:return!!t.value||!!r.value;default:throw SyntaxError("SyntaxError: Invalid logical expression.")}}async evaluateConditionalExpression(e){let t=await this.evaluateExpression(e.leftOperand),r=await this.evaluateExpression(e.rightOperand);switch(e.constructor){case O:return t.value==r.value;case A:return t.value!=r.value;case b:return t.value>r.value;case m:return t.value<r.value;case L:return t.value>=r.value;case R:return t.value<=r.value;default:throw SyntaxError("SyntaxError: Invalid conditional expression.")}}async evaluateExpression(e){if(e instanceof l)return e instanceof c?this.evaluateString(e.value):e;if(e instanceof M)return await this.executeFunctionCall(e);if(e instanceof E){let t=e.value,r=this.variableTable.getVariableValue(t);return r instanceof s?await this.evaluateExpression(r):r}if(e instanceof d)return await this.evaluateArithmeticExpression(e);if(e instanceof w){let t=e.operand;return new u(-t.value)}if(e instanceof N){let t=await this.evaluateConditionalExpression(e);return new p(t)}if(e instanceof g){let t=await this.evaluateLogicalExpression(e);return new p(t)}else throw SyntaxError("SyntaxError: Invalid expression.")}};await ee.interpret(X)}catch(r){r instanceof Error&&console.error(r.message)}